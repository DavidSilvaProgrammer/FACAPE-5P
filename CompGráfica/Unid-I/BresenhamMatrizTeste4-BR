#include <stdio.h>

#define LINHAS 10
#define COLUNAS 20

void bresenham(int x0, int y0, int x1, int y1, int matriz[LINHAS][COLUNAS]) {
    int dx = x1 - x0;
    int dy = y1 - y0;
    int sx, sy, erro, e2;

    if (dy < 0) {
        dy = -dy;
        sy = -1;
    } else {
        sy = 1;
    }

    if (dx < 0) {
        dx = -dx;
        sx = -1;
    } else {
        sx = 1;
    }

    erro = dx - dy;

    while (x0 != x1 || y0 != y1) {
        if (x0 >= 0 && x0 < COLUNAS && y0 >= 0 && y0 < LINHAS) {
            matriz[y0][x0] = 1; // Define o pixel como parte da linha
        }

        e2 = 2 * erro;
        if (e2 > -dy) {
            erro -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            erro += dx;
            y0 += sy;
        }
    }
}

int main() {
    int matriz[LINHAS][COLUNAS] = {0}; // Inicializa a matriz com zeros

    // Solicita os pontos inicial e final da linha ao usu√°rio
    int x0, y0, x1, y1;
    printf("OBS: Limite de x: 0 a 19\n\tLimite de y: 0 a 9\n");
    printf("\tx pontos horizontais e y pontos verticais\n\n");
    printf("Digite as coordenadas do ponto inicial (x0 y0): ");
    scanf("%d %d", &x0, &y0);
    printf("Digite as coordenadas do ponto final (x1 y1): ");
    scanf("%d %d", &x1, &y1);
    printf("\n");
    
    // Desenha a linha usando o algoritmo de Bresenham
    bresenham(x0, y0, x1, y1, matriz);

    // Imprime a matriz
    for (int i = 0; i < LINHAS; i++) {
        for (int j = 0; j < COLUNAS; j++) {
            printf("%d ", matriz[i][j]);
        }
        printf("\n");
    }

    return 0;
}

/*
Este programa em C implementa o algoritmo de Bresenham para desenhar uma linha em uma matriz bidimensional. Vamos entender cada parte:

    Defini√ß√£o de Constantes:
        LINHAS e COLUNAS definem o tamanho da matriz que representa a tela onde desenharemos a linha.
        A fun√ß√£o bresenham recebe os pontos inicial e final da linha, bem como a matriz onde desenharemos.

    Fun√ß√£o bresenham:
        Calcula as diferen√ßas em x e y entre os pontos inicial e final.
        Determina os incrementos sx e sy com base nas diferen√ßas.
        Inicializa o erro erro como a diferen√ßa em x.
        O loop continua at√© que os pontos sejam iguais.
        Se o ponto atual estiver dentro dos limites da matriz, marcamos esse pixel como parte da linha.
        Atualizamos o erro e os pontos x e y conforme o algoritmo de Bresenham.

    Fun√ß√£o main:
        Inicializa a matriz com zeros.
        Solicita ao usu√°rio os pontos inicial e final da linha.
        Chama a fun√ß√£o bresenham para desenhar a linha na matriz.
        Imprime a matriz resultante.

O algoritmo de Bresenham √© eficiente e usado para desenhar linhas em sistemas gr√°ficos. 
Ele calcula os pixels discretos que formam a linha, evitando o uso de n√∫meros reais e arredondamentos. 
O resultado √© uma representa√ß√£o aproximada da linha na matriz. Neste caso, a matriz impressa mostra os 
pixels que fazem parte da linha entre os pontos fornecidos pelo usu√°rio.


Vou explicar o prop√≥sito de cada uma dessas vari√°veis no c√≥digo:



    sx e sy:
        Essas vari√°veis representam os incrementos nos eixos x e y, respectivamente.
        O valor de sx √© 1 se a diferen√ßa em x entre os pontos inicial e final for positiva, caso contr√°rio, √© -1.
        O valor de sy √© 1 se a diferen√ßa em y entre os pontos inicial e final for positiva, caso contr√°rio, √© -1.
        Esses incrementos s√£o usados para determinar a dire√ß√£o em que a linha est√° sendo desenhada.

    erro:
        A vari√°vel erro representa o erro acumulado durante o desenho da linha.
        Inicialmente, √© definida como a diferen√ßa em x entre os pontos inicial e final.
        √Ä medida que a linha √© desenhada, o erro √© atualizado com base nas diferen√ßas em x e y.
        O algoritmo de Bresenham usa esse erro para decidir qual pixel deve ser marcado como parte da linha.

    e2:
        A vari√°vel e2 √© um valor auxiliar usado para otimizar o algoritmo.
        Ela √© calculada como o dobro do erro.
        Comparando e2 com as diferen√ßas em x e y, o algoritmo decide se deve mover-se horizontalmente ou verticalmente.

Essas vari√°veis s√£o essenciais para o funcionamento correto do algoritmo de Bresenham, que desenha uma linha de forma 
eficiente e precisa em uma matriz bidimensional.
*/


/*
Segunda explica√ß√£o:

Claro! O c√≥digo em C que voc√™ forneceu implementa o algoritmo de Bresenham para desenhar uma linha em uma matriz bidimensional. Vou explicar como ele segue a l√≥gica do algoritmo:

    C√°lculo das diferen√ßas em x e y:
        dx = x1 - x0
        dy = y1 - y0

    Determina√ß√£o dos sinais de incremento (sx e sy):
        Se dy for negativo, inverte o sinal de dy e define sy = -1.
        Caso contr√°rio, sy = 1.
        O mesmo √© feito para dx e sx.

    Inicializa√ß√£o do par√¢metro de erro (erro):
        erro = dx - dy

    Loop principal:
        Enquanto x0 n√£o for igual a x1 ou y0 n√£o for igual a y1:
            Se as coordenadas (x0, y0) estiverem dentro dos limites da matriz:
                Define o pixel na posi√ß√£o (x0, y0) como parte da linha (atribui 1 √† matriz).
            Calcula e2 = 2 * erro.
            Se e2 for maior que -dy, atualiza erro e incrementa ou decrementa x0 (dependendo do sinal de sx).
            Se e2 for menor que dx, atualiza erro e incrementa ou decrementa y0 (dependendo do sinal de sy).

    Impress√£o da matriz resultante:
        O c√≥digo imprime a matriz preenchida com 0s e 1s, onde 1 representa os pixels que fazem parte da linha desenhada.

Lembre-se de que a matriz resultante ser√° impressa no console, mostrando os pixels que formam a linha entre os pontos inicial e final que voc√™ especificou. üòä
*/

/*
Explica√ß√£o 3 detalhada. Foco na fun√ß√£o e suas vari√°veis:

Claro! Vamos analisar cada parte do c√≥digo e entender o significado de cada vari√°vel e sua fun√ß√£o no algoritmo de Bresenham:

    Vari√°veis e seus prop√≥sitos:
        dx (diferen√ßa em x): Representa a diferen√ßa entre as coordenadas x do ponto final e do ponto inicial.
        dy (diferen√ßa em y): Representa a diferen√ßa entre as coordenadas y do ponto final e do ponto inicial.
        sx (incremento em x): Determina se o pr√≥ximo pixel na dire√ß√£o x deve ser incrementado ou decrementado.
        sy (incremento em y): Determina se o pr√≥ximo pixel na dire√ß√£o y deve ser incrementado ou decrementado.
        erro: √â um par√¢metro usado para acompanhar o erro acumulado durante o desenho da linha.
        e2: √â uma vari√°vel auxiliar usada para otimizar o c√°lculo do erro.

    Explica√ß√£o detalhada:

        Determina√ß√£o dos incrementos sx e sy:
            Se dy for negativo, significa que a linha est√° inclinada para baixo (de cima para baixo). 
        Nesse caso, invertemos o sinal de dy e definimos sy = -1.
            Caso contr√°rio, a linha est√° inclinada para cima (de baixo para cima), ent√£o sy √© definido como 1.
            O mesmo racioc√≠nio √© aplicado para dx e sx.

        Inicializa√ß√£o do erro (erro):
            O erro √© inicializado com a diferen√ßa em x (erro = dx - dy).

        Loop principal:
            O loop continua at√© que os pontos (x0, y0) sejam iguais aos pontos finais (x1, y1).
            Se as coordenadas atuais (x0, y0) estiverem dentro dos limites da matriz, marcamos esse pixel 
            como parte da linha (atribu√≠mos 1 √† matriz).
            Calculamos e2 = 2 * erro.
            Se e2 for maior que -dy, atualizamos o erro e incrementamos ou decrementamos x0 (dependendo do sinal 
            de sx).
            Se e2 for menor que dx, atualizamos o erro e incrementamos ou decrementamos y0 (dependendo do sinal 
            de sy).

        O que √© o erro?
            O erro √© uma medida de qu√£o longe a linha desenhada est√° da posi√ß√£o ideal (linha reta). 
        Ele √© usado para determinar qual pixel deve ser escolhido na pr√≥xima itera√ß√£o para aproximar a linha reta.

        Nomes das vari√°veis:
            Os nomes das vari√°veis s√£o escolhidos para serem concisos e representativos de sua fun√ß√£o. 
            Por exemplo, dx e dy indicam as diferen√ßas nas coordenadas x e y, respectivamente. sx e sy 
            representam os incrementos em x e y. O nome erro √© usado para acompanhar o erro acumulado.

Espero que esta explica√ß√£o tenha esclarecido o funcionamento do algoritmo de Bresenham e o papel de cada vari√°vel! 
*/

/*
Explica√ß√£o 4:

erro: Essa vari√°vel rastreia o erro acumulado durante o desenho da linha. 
Ela √© atualizada a cada itera√ß√£o do loop enquanto a linha est√° sendo desenhada. 
O valor de erro √© usado para determinar se o pr√≥ximo pixel a ser pintado deve ser na 
dire√ß√£o horizontal ou vertical.

e2: Essa vari√°vel √© calculada como o dobro do valor de erro. Ela tamb√©m √© usada para 
tomar decis√µes sobre qual dire√ß√£o seguir (horizontal ou vertical) ao desenhar a linha. 
Se e2 for maior que o negativo da diferen√ßa em y (ou seja, e2 > -dy), o pr√≥ximo pixel ser√° 
na dire√ß√£o horizontal. Se e2 for menor que a diferen√ßa em x (ou seja, e2 < dx), o pr√≥ximo pixel 
ser√° na dire√ß√£o vertical.

*/
Explica√ß√£o 5:

Vamos analisar essa parte final da fun√ß√£o em detalhes:

    while (x0 != x1 || y0 != y1):
        Este √© o loop principal que executa o algoritmo de Bresenham at√© que o ponto final (x1, y1) seja alcan√ßado.
        O loop continua enquanto as coordenadas atuais (x0, y0) n√£o coincidirem com as coordenadas do ponto final (x1, y1).

    if (x0 >= 0 && x0 < COLUNAS && y0 >= 0 && y0 < LINHAS):
        Esta condi√ß√£o verifica se as coordenadas atuais (x0, y0) est√£o dentro dos limites da matriz.
        Se estiverem dentro dos limites, o pixel correspondente na matriz √© definido como parte da linha (ou seja, atribu√≠do o valor 1).

    e2 = 2 * erro;:
        Aqui, calculamos o dobro do valor atual de erro e armazenamos em e2.
        O valor de e2 √© usado para tomar decis√µes sobre qual dire√ß√£o seguir (horizontal ou vertical) ao desenhar a linha.

    if (e2 > -dy):
        Se e2 for maior que o negativo da diferen√ßa em y (ou seja, e2 > -dy), o pr√≥ximo pixel a ser pintado ser√° na dire√ß√£o horizontal.
        Nesse caso, subtra√≠mos dy do valor de erro e incrementamos x0 na dire√ß√£o especificada por sx.

    if (e2 < dx):
        Se e2 for menor que a diferen√ßa em x (ou seja, e2 < dx), o pr√≥ximo pixel a ser pintado ser√° na dire√ß√£o vertical.
        Nesse caso, adicionamos dx ao valor de erro e incrementamos y0 na dire√ß√£o especificada por sy.

Em resumo, esse trecho de c√≥digo √© respons√°vel por atualizar as coordenadas (x0, y0) e o valor de erro durante o processo de desenho da linha usando o algoritmo de Bresenham. Ele garante que a linha seja tra√ßada corretamente, ajustando as coordenadas conforme necess√°rio para percorrer o caminho mais pr√≥ximo entre os pontos inicial e final. 
O resultado final √© uma linha reta representada na matriz matriz.

*/

